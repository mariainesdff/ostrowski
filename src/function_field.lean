/-
Copyright (c) 2022 María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos-Fernández
-/
import field_theory.ratfunc
import ring_theory.dedekind_domain.adic_valuation
import data.polynomial.basic
import analysis.special_functions.log.base
import basic

/-!
# Ostrowski's theorem for K(X)

## References
* https://kconrad.math.uconn.edu/blurbs/gradnumthy/ostrowskiF(T).pdf

## Tags
ring_norm, ostrowski
-/

noncomputable theory

open polynomial

open_locale polynomial big_operators

section infty

/-- The norm on K(X) associated to the place at infinity. -/
noncomputable! def mul_ring_norm.infty (K : Type*) [field K] [decidable_eq (ratfunc K)] 
  (c : ℝ) (hc_pos : 0 < c) (hc_one_lt : 1 < c) : mul_ring_norm (ratfunc K) :=
{ to_fun := λ r, if r = 0 then 0 else c ^ r.int_degree,
  map_zero' := sorry,
  add_le' := sorry,
  neg' := λ r,
  begin
    by_cases r = 0,
    { simp only [h, neg_zero] } ,
    { have h₁ : ¬ -r = 0,
      { intro h₁,
        apply h,
        exact neg_eq_zero.1 h₁ },
      simp only [h, h₁, ratfunc.int_degree_neg] }
  end,
  map_one' := sorry,
  map_mul' :=
  begin
    intros r s,
    simp [mul_eq_zero, ite_mul, mul_ite, mul_zero, zero_mul],
    by_cases r = 0 ∨ s = 0,
    { simp only [h, if_true],
      cases h,
      { simp only [h, eq_self_iff_true, if_true, if_t_t] },
      { simp only [h, eq_self_iff_true, if_true] } },
    { simp only [h, if_false],
      rw not_or_distrib at h,
      cases h with h₁ h₂,
      simp only [h₁, h₂, if_false],
      rw ratfunc.int_degree_mul h₁ h₂,
      repeat {rw ←real.rpow_int_cast},
      push_cast,
      exact real.rpow_add hc_pos _ _ }
  end,
  eq_zero_of_map_eq_zero' := λ x hx,
  begin
    by_contra,
    simp only [h, if_false] at hx,
    linarith [zpow_eq_zero hx],
  end }

@[simp] lemma mul_ring_norm.infty_def (K : Type*) [field K] [decidable_eq (ratfunc K)] (c : ℝ) 
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) (r : ratfunc K):
    mul_ring_norm.infty K c hc_pos hc_one_lt r = if r = 0 then 0 else c ^ r.int_degree := rfl

lemma mul_ring_norm.infty_is_nonarchimedean (K : Type*) [field K] [decidable_eq (ratfunc K)] (c : ℝ)
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) :
  is_nonarchimedean (mul_ring_norm.infty K c hc_pos hc_one_lt) :=
begin
  intros r s,
  simp only [mul_ring_norm.infty_def, le_max_iff],
  by_cases r + s = 0,
  { simp only [h, eq_self_iff_true, if_true],
    sorry},
  { simp only [h, if_false],
    by_cases h₁ : r = 0,
    { right,
      have h₂ : ¬ s = 0,
      { intro h₃,
        apply h,
        simp only [h₁, h₃, add_zero] },
      simp only [h₁, h₂, zero_add, if_false] },
    { have h₂ : ¬ s = 0 := sorry, -- this is false,
      simp only [h₁, h₂, if_false],

      sorry} }
end

end infty

/-- The maximal ideal on K[X] generated by an irreducible polynomial. -/
def polynomial.maximal_ideal_of_irreducible {K : Type*} [field K] [decidable_eq (ratfunc K)]
  {p : polynomial K} (hp : irreducible p) : is_dedekind_domain.height_one_spectrum (K[X]) :=
{ as_ideal := ideal.span({p}),
  is_prime := (ideal.span_singleton_prime (prime.ne_zero 
    (principal_ideal_ring.irreducible_iff_prime.mp hp))).mpr 
      (principal_ideal_ring.irreducible_iff_prime.mp hp),
  ne_bot   := by simp only [ne.def, ideal.span_singleton_eq_bot, 
    prime.ne_zero (principal_ideal_ring.irreducible_iff_prime.mp hp), not_false_iff] }

section adic

/-- The norm on K(X) associated to an irreducible polynomial. -/
noncomputable! def mul_ring_norm.adic {K : Type*} [field K] [decidable_eq (ratfunc K)] (c : ℝ) 
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) {p : polynomial K} (hp : irreducible p) :
    mul_ring_norm (ratfunc K) :=
{ to_fun := λ r, if hr : r = 0 then 0 else c ^ multiplicative.to_add (with_zero.unzero
  ((@polynomial.maximal_ideal_of_irreducible K _ _ p hp).valuation.ne_zero_iff.mpr hr)),
  map_zero' := sorry,
  add_le' := 
  begin
    intros r s,
    by_cases r + s = 0,
    { simp only [h, dif_pos],
      by_cases hr : r = 0,
      { have hs : s = 0,
        {sorry},
        simp only [hs, hr, dif_pos],
        linarith },
      { have hs : ¬ s = 0,
        {sorry},
        simp only [hs, hr, not_false_iff, dif_neg],
        exact add_nonneg (zpow_nonneg (le_of_lt hc_pos) _) 
          (zpow_nonneg (le_of_lt hc_pos) _) } },
    { simp only [h, not_false_iff, dif_neg],
      by_cases hr : r = 0,
      { have hs : ¬ s = 0,
        {sorry},
        simp only [hr, hs, not_false_iff, zero_add, dif_pos, dif_neg] },
      { by_cases hs : s = 0,
        {sorry},
        {sorry} } }
  end,
  neg' := sorry,
  map_one' := sorry,
  map_mul' :=
  begin
    intros x y,
    simp [mul_eq_zero, valuation.map_mul],
    by_cases (x = 0 ∨ y = 0),
    {sorry},
    { rw not_or_distrib at h,
      simp only [h.1, h.2, or_self, not_false_iff, dif_neg],
      rw ←@zpow_add₀ _ _ c (by linarith),
      congr,
      rw ←to_add_mul,
      congr,
      rw ←with_zero.coe_inj,
      push_cast,
      repeat {rw with_zero.coe_unzero} },
  end,
  eq_zero_of_map_eq_zero' :=
  begin
    intros x hx,
    by_contra,
    simp only [h, not_false_iff, dif_neg] at hx,
    linarith [zpow_eq_zero hx]
  end }

@[simp] lemma mul_ring_norm.adic_def {K : Type*} [field K] [decidable_eq (ratfunc K)] 
  (c : ℝ) (hc_pos : 0 < c) (hc_one_lt : 1 < c) {p : polynomial K} (hp : irreducible p) 
    (r : ratfunc K): mul_ring_norm.adic c hc_pos hc_one_lt hp r = if hr : r = 0 then 0 else 
      c ^ multiplicative.to_add (with_zero.unzero ((
        @polynomial.maximal_ideal_of_irreducible K _ _ p hp).valuation.ne_zero_iff.mpr hr)) 
:= rfl

lemma mul_ring_norm.adic_is_nonarchimedean (K : Type*) [field K] [decidable_eq (ratfunc K)] (c : ℝ)
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) {p : polynomial K} (hp : irreducible p) :
  is_nonarchimedean (@mul_ring_norm.adic K _ _ c hc_pos hc_one_lt p hp) :=
begin
  intros x y,
  simp only [nonempty_of_inhabited, mul_ring_norm.adic_def, le_max_iff],
  by_cases x + y = 0,
  {sorry},
  { simp only [h, not_false_iff, dif_neg],
    by_cases hx : x = 0,
    { have hy : ¬ y = 0,
      {sorry},
      simp only [hx, hy, not_false_iff, zero_add, dif_neg, le_refl, or_true] },
    { left,
      simp only [hx, not_false_iff, dif_neg],
      repeat {rw ←real.rpow_int_cast},
      apply real.rpow_le_rpow_of_exponent_le,
      { linarith },
      { sorry } } }
end

lemma mul_ring_norm.is_nonarchimedaen_eq_max_of_neq {R : Type*} [non_assoc_ring R] 
  {f : mul_ring_norm R} (hf : is_nonarchimedean f) {r s : R} (h_neq : f r ≠ f s) : 
    f (r + s) = max (f r) (f s) :=
begin
  have hf₁ := hf,
  specialize hf r s,
  cases ne.lt_or_lt h_neq with h₁ h₂,
  { specialize hf₁ (r + s) (-r),
    simp only [add_neg_cancel_comm, map_neg_eq_map, le_max_iff] at hf₁,
    cases hf₁ with h₃ h₄,
    { have hrs : f r ≤ f s := by linarith,
      rw max_eq_right hrs at hf ⊢,
      linarith },
    { linarith } },
  { specialize hf₁ (r + s) (-s),
    simp only [add_neg_cancel_right, map_neg_eq_map, le_max_iff] at hf₁,
    cases hf₁ with h₃ h₄,
    { have hrs : f s ≤ f r := by linarith,
      rw max_eq_left hrs at hf ⊢,
      linarith },
    { linarith } }
end

end adic

-- https://math.stackexchange.com/questions/1748861/does-every-non-archimedean-absolute-value-satisfy-the-ultrametric-inequality/2011734#2011734

open filter

lemma Sum_le {R : Type*} [ring R] (f : mul_ring_norm R) (n : ℕ) (ι : ℕ → R) : 
  f (∑ i in finset.range n, ι i) ≤ ∑ i in finset.range n, f (ι i) :=
begin
  induction n with n hn,
  { simp only [finset.range_zero, finset.sum_empty, map_zero] },
  { rw finset.sum_range_succ,
    rw finset.sum_range_succ,
    calc f (∑ (x : ℕ) in finset.range n, ι x + ι n)
        ≤ f (∑ i in finset.range n, ι i) + f (ι n) : f.add_le' _ _
    ... ≤ (∑ i in finset.range n, f (ι i)) + f (ι n) : add_le_add_right hn _ }
end

lemma is_nonarchimedean_iff_exists_ne_zero_map_nat_mul_le_one {R : Type*} 
  [comm_ring R] {f : mul_ring_norm R} :
    is_nonarchimedean f ↔ (∃ x : R, x ≠ 0 ∧ ∀ n : ℕ, f (n * x) ≤ 1) :=
begin
  split,
  { sorry
    --intros hf,
    --refine ⟨1, one_ne_zero, _⟩,
    --intro n,
    --rw mul_one,
    --exact is_nonarchimedean.map_nat_cast_le_one hf n 
  },
  { intros H y z,
    obtain ⟨x, hx, hn⟩ := H,
    have hn1 : ∀ (n : ℕ), f n ≤ 1 / (f x),
    { intro n,
      
      sorry},
    have hyz : ∀ (k : ℕ), f (y + z) ^ k ≤ ((k + 1) / f x) * max (f y) (f z) ^ k,
    { intro k,
      rw ← map_pow _ _ _,
      rw add_pow y z k,
      apply le_trans (Sum_le f (k + 1) _),
      have h : ∑ (i : ℕ) in finset.range (k + 1), f (y ^ i * z ^ (k - i) * (k.choose i))
        ≤ ∑ (i : ℕ) in finset.range (k + 1), (f y) ^ i * (f z) ^ (k - i) / (f x),
      { apply finset.sum_le_sum,
        intros i hi,
        rw [map_mul, map_mul, map_pow,map_pow],
        specialize hn1 (k.choose i),
        have hyz : 0 ≤ f y ^ i * f z ^ (k - i),
        { apply mul_nonneg,
          { apply pow_nonneg,
            simp only [map_nonneg] },
          { apply pow_nonneg,
            simp only [map_nonneg] } },
        rw ← mul_one_div,
        exact (mul_le_mul_of_nonneg_left hn1 hyz) },
      apply le_trans h,
      have h1 : ∑ (i : ℕ) in finset.range (k + 1), (f y) ^ i * (f z) ^ (k - i) / (f x)
        ≤ ∑ (i : ℕ) in finset.range (k + 1), (max (f y) (f z)) ^ k / (f x),
      { apply finset.sum_le_sum,
        intros i hi,
        apply div_le_div_of_le_of_nonneg,
        { by_cases hyz : (f y) ≤ (f z),
          { simp only [hyz, max_eq_right],
            calc f y ^ i * f z ^ (k - i) ≤ f z ^ i * f z ^ (k - i) : 
              begin 
                apply mul_le_mul_of_nonneg_right,
                { apply pow_le_pow_of_le_left,
                  { simp only [map_nonneg] },
                  { exact hyz } },
                { apply pow_nonneg,
                  simp only [map_nonneg] }
              end
            ...                          = f z ^ k :
              begin
                rw ← pow_add,
                congr,
                simp only [finset.mem_range] at hi,
                have hi₁ : i ≤ k := by linarith,
                zify,
                ring,
              end
          },
          { have h₁ : f z ≤ f y := by linarith,
            rw max_eq_left h₁,
            calc f y ^ i * f z ^ (k - i) ≤ f y ^ i * f y ^ (k - i) : 
              begin
                apply mul_le_mul_of_nonneg_left,
                { apply pow_le_pow_of_le_left,
                  { simp only [map_nonneg] },
                  { exact h₁ } },
                { apply pow_nonneg,
                  simp only [map_nonneg]}
              end
            ...                          = f y ^ k :
              begin
                rw ← pow_add,
                congr,
                simp only [finset.mem_range] at hi,
                have hi₁ : i ≤ k := by linarith,
                zify,
                ring,
              end
          } },
        { simp only [map_nonneg] } },
      apply le_trans h1,
      rw finset.sum_const ((max (f y) (f z)) ^ k / (f x)),
      simp only [finset.card_range, nsmul_eq_mul, nat.cast_add, algebra_map.coe_one],
      field_simp },
    have hyz1 : ∀ (k : ℕ), k ≠ 0 → 
      f (y + z) ≤ ((k + 1) / f x) ^ (1 / (k : ℝ)) * max (f y) (f z),
    { intros k hk,
      specialize hyz k,
      refine le_of_pow_le_pow k _ (nat.pos_of_ne_zero hk) _,
      { apply mul_nonneg,
        { apply real.rpow_nonneg_of_nonneg,
          apply div_nonneg,
          { norm_cast,
            exact zero_le (k + 1) },
          { simp only [map_nonneg] } },
        { by_cases h : (f y) ≤ (f z),
          { simp only [h, max_eq_right, map_nonneg] },
          { simp only [le_max_iff, map_nonneg, or_self] }} },
      { rw mul_pow,
        nth_rewrite 1 ← real.rpow_nat_cast,
        rw ← real.rpow_mul _ (1 / (k : ℝ)),
        { field_simp,
          rw div_self,
          { rw real.rpow_one,
            exact hyz },
          norm_cast,
          exact hk },
        apply div_nonneg,
        { norm_cast,
          exact zero_le (k + 1) },
        { simp only [map_nonneg] } } }, clear hyz,
    have limit : filter.tendsto (λ n : ℕ, ((n + 1 : ℝ) / (f x)) ^ (1 / (n : ℝ)) 
      * max (f y) (f z)) filter.at_top (nhds (max (f y) (f z))),
    { have triv : max (f y) (f z) = 1 * max (f y) (f z) := by rwa one_mul,
      nth_rewrite 0 triv,
      apply filter.tendsto.mul_const (max (f y) (f z)),

      sorry},
    apply ge_of_tendsto limit _,
    simp only [filter.eventually_at_top, ge_iff_le],
    refine ⟨1, _⟩,
    intros b hb,
    have hb1 : b ≠ 0 := by linarith,
    specialize hyz1 b hb1,
    exact hyz1 }
end

example (a b c : ℝ) (hc : 0 ≤ c) (hab : a ≤ b) : c * a ≤ c * b := mul_le_mul_of_nonneg_left hab hc

lemma unknown_name1 {K : Type*} [field K] [decidable_eq (ratfunc K)]
  {f : mul_ring_norm (ratfunc K)} (hf_nontriv : f ≠ 1) 
    (hf_triv_K : ∀ {x : K} (hx : x ≠ 0), f (ratfunc.C x) = 1) :
      is_nonarchimedean f :=
begin
  rw is_nonarchimedean_iff_exists_ne_zero_map_nat_mul_le_one,
  refine ⟨1, _⟩,
  simp only [ne.def, one_ne_zero, not_false_iff, mul_one, true_and],
  intro n,
  have hn1 : ratfunc.C (n : K) = (n : ratfunc K),
  { simp only [map_nat_cast] },
  by_cases h : (n : K) = 0,
  { have hn : (n : ratfunc K) = 0,
    { rw ← hn1,
      rw h,
      simp only [map_zero] },
    rw hn,
    simp only [map_zero, zero_le_one] },
  { specialize hf_triv_K h,
    rw hn1 at hf_triv_K,
    rw hf_triv_K }
end

lemma unknown_name {R : Type*} [non_assoc_ring R] {f : mul_ring_norm R} 
  (hf : is_nonarchimedean f) (s : finset ℕ) {g : ℕ → R} {a : ℕ}
    (h_max : ∀ p : ℕ, f (g p) ≤ f (g a)) :
      f (∑ p in s, g p) = f (g a) :=
begin
  sorry
end

/-- Ostrowski's Theorem -/
theorem rat_ring_norm_p_adic_or_real (K : Type*) [field K] [decidable_eq (ratfunc K)]
  (c : ℝ) (hc_pos : 0 < c) (hc_one_lt : 1 < c) (f : mul_ring_norm (ratfunc K))
    (hf_nontriv : f ≠ 1) (hf_triv_K : ∀ {x : K} (hx : x ≠ 0), f (ratfunc.C x) = 1) :
      (mul_ring_norm.equiv f (mul_ring_norm.infty K c hc_pos hc_one_lt)) ∨
        ∃ (p : K[X]) [hp : irreducible p],
          mul_ring_norm.equiv f (@mul_ring_norm.adic K _ _ c hc_pos hc_one_lt p hp) :=
begin
  by_cases 1 < f (ratfunc.mk X 1),
  { left,
    let c₁ := 1 / f (ratfunc.mk X 1),
    have hc₁ : 0 < c₁,
    {sorry}, -- easy
    have hc₂ : 0 ≤ c₁,
    { linarith [hc₁] },
    have hc₃ : c₁ ≠ 1,
    {sorry}, -- easy as well
    have hc : c ≠ 0,
    { linarith },
    have hc1 : 0 ≤ c,
    { linarith },
    have h₁ : ∀ x : K[X], f (ratfunc.mk x 1) = c₁ ^ -(x.nat_degree : ℝ),
    { intro x,
      nth_rewrite 0 as_sum_support_C_mul_X_pow x,
      have h₁ : ratfunc.mk (x.support.sum (λ (i : ℕ), C (x.coeff i) * X ^ i)) 1
      = ∑ p in x.support, (ratfunc.mk (C (x.coeff p) * X ^ p) 1),
      {sorry},
      rw h₁, clear h₁,
      have h₂ : ∀ (p : ℕ), f (ratfunc.mk (C (x.coeff p) * X ^ p) 1)
        ≤ f (ratfunc.mk (C (x.coeff (nat_degree x)) * X ^ (nat_degree x)) 1),
      {sorry},
      have hf : is_nonarchimedean f,
      { exact unknown_name1 hf_nontriv @hf_triv_K },
      rw unknown_name hf (x.support) h₂,
      clear h₂,
      have h₃ : f (ratfunc.mk (C (x.coeff x.nat_degree) * X ^ x.nat_degree) 1)
         = f (ratfunc.mk (C (x.coeff x.nat_degree)) 1) * f (ratfunc.mk (X ^ x.nat_degree) 1),
      {sorry},
      rw h₃,
      clear h₃,
      have h₄ : f (ratfunc.mk (C (x.coeff x.nat_degree)) 1) = 1,
      {sorry},
      rw h₄,
      clear h₄,
      rw one_mul,
      have h₅ : f (ratfunc.mk (X ^ x.nat_degree) 1) = (f (ratfunc.mk X 1)) ^ (x.nat_degree),
      {sorry},
      rw h₅,
      clear h₅,
      dsimp [c₁],
      rw one_div,
      rw ←real.rpow_neg_one,
      rw ←real.rpow_mul,
      { simp only [neg_mul, one_mul, neg_neg, real.rpow_nat_cast] },
      sorry}, -- main step here
    refine ⟨-real.logb c₁ c, _, _⟩,
    {sorry}, -- 0 < -real.logb c₁ c-
    { ext,
      rw [mul_ring_norm.infty_def],
      by_cases h₂ : x = 0,
      {sorry}, -- easy
      { simp only [h₂, if_false],
        have h₃ := h₁ (x.num),
        specialize h₁ x.denom,
        have h₄ : x = (ratfunc.mk x.num 1) / (ratfunc.mk x.denom 1),
        {sorry}, -- quite tricky here
        rw h₄,
        have h₅ : f (ratfunc.mk x.num 1 / ratfunc.mk x.denom 1) = f (ratfunc.mk x.num 1) / f (ratfunc.mk x.denom 1),
        {sorry}, -- This should be a separate lemma
        rw h₅,
        rw [h₁, h₃],
        rw ←real.rpow_sub hc₁,
        field_simp,
        rw ←real.rpow_mul hc₂,
        rw ←neg_mul_comm,
        field_simp,
        rw mul_comm,
        rw real.rpow_mul hc₂,
        rw real.rpow_logb_eq_abs hc₁ hc₃ hc,
        rw abs_eq_self.2 hc1,
        dsimp [ratfunc.int_degree],
        rw ←real.rpow_int_cast,
        push_cast } } },
  { right,
    sorry}
end
