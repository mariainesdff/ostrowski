/-
Copyright (c) 2022 María Inés de Frutos-Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos-Fernández
-/
import field_theory.ratfunc
import ring_theory.dedekind_domain.adic_valuation
import data.polynomial.basic
import analysis.special_functions.log.base
import basic

/-!
# Ostrowski's theorem for K(X)

## References
* https://kconrad.math.uconn.edu/blurbs/gradnumthy/ostrowskiF(T).pdf

## Tags
ring_norm, ostrowski
-/

noncomputable theory

open polynomial

open_locale polynomial big_operators

section infty

/-- The norm on K(X) associated to the place at infinity. -/
noncomputable! def mul_ring_norm.infty (K : Type*) [field K] [decidable_eq (ratfunc K)] 
  (c : ℝ) (hc_pos : 0 < c) (hc_one_lt : 1 < c) : mul_ring_norm (ratfunc K) :=
{ to_fun := λ r, if r = 0 then 0 else c ^ r.int_degree,
  map_zero' := sorry,
  add_le' := sorry,
  neg' := λ r,
  begin
    by_cases r = 0,
    { simp only [h, neg_zero] } ,
    { have h₁ : ¬ -r = 0,
      { intro h₁,
        apply h,
        exact neg_eq_zero.1 h₁ },
      simp only [h, h₁, ratfunc.int_degree_neg] }
  end,
  map_one' := sorry,
  map_mul' :=
  begin
    intros r s,
    simp [mul_eq_zero, ite_mul, mul_ite, mul_zero, zero_mul],
    by_cases r = 0 ∨ s = 0,
    { simp only [h, if_true],
      cases h,
      { simp only [h, eq_self_iff_true, if_true, if_t_t] },
      { simp only [h, eq_self_iff_true, if_true] } },
    { simp only [h, if_false],
      rw not_or_distrib at h,
      cases h with h₁ h₂,
      simp only [h₁, h₂, if_false],
      rw ratfunc.int_degree_mul h₁ h₂,
      repeat {rw ←real.rpow_int_cast},
      push_cast,
      exact real.rpow_add hc_pos _ _ }
  end,
  eq_zero_of_map_eq_zero' := λ x hx,
  begin
    by_contra,
    simp only [h, if_false] at hx,
    linarith [zpow_eq_zero hx],
  end }

@[simp] lemma mul_ring_norm.infty_def (K : Type*) [field K] [decidable_eq (ratfunc K)] (c : ℝ) 
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) (r : ratfunc K):
    mul_ring_norm.infty K c hc_pos hc_one_lt r = if r = 0 then 0 else c ^ r.int_degree := rfl

lemma mul_ring_norm.infty_is_nonarchimedean (K : Type*) [field K] [decidable_eq (ratfunc K)] (c : ℝ)
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) :
  is_nonarchimedean (mul_ring_norm.infty K c hc_pos hc_one_lt) :=
begin
  intros r s,
  simp only [mul_ring_norm.infty_def, le_max_iff],
  by_cases r + s = 0,
  { simp only [h, eq_self_iff_true, if_true],
    sorry},
  { simp only [h, if_false],
    by_cases h₁ : r = 0,
    { right,
      have h₂ : ¬ s = 0,
      { intro h₃,
        apply h,
        simp only [h₁, h₃, add_zero] },
      simp only [h₁, h₂, zero_add, if_false] },
    { have h₂ : ¬ s = 0 := sorry, -- this is false,
      simp only [h₁, h₂, if_false],

      sorry} }
end

end infty

/-- The maximal ideal on K[X] generated by an irreducible polynomial. -/
def polynomial.maximal_ideal_of_irreducible {K : Type*} [field K] [decidable_eq (ratfunc K)]
  {p : polynomial K} (hp : irreducible p) : is_dedekind_domain.height_one_spectrum (K[X]) :=
{ as_ideal := ideal.span({p}),
  is_prime := (ideal.span_singleton_prime (prime.ne_zero 
    (principal_ideal_ring.irreducible_iff_prime.mp hp))).mpr 
      (principal_ideal_ring.irreducible_iff_prime.mp hp),
  ne_bot   := by simp only [ne.def, ideal.span_singleton_eq_bot, 
    prime.ne_zero (principal_ideal_ring.irreducible_iff_prime.mp hp), not_false_iff] }

section adic

/-- The norm on K(X) associated to an irreducible polynomial. -/
noncomputable! def mul_ring_norm.adic {K : Type*} [field K] [decidable_eq (ratfunc K)] (c : ℝ) 
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) {p : polynomial K} (hp : irreducible p) :
    mul_ring_norm (ratfunc K) :=
{ to_fun := λ r, if hr : r = 0 then 0 else c ^ multiplicative.to_add (with_zero.unzero
  ((@polynomial.maximal_ideal_of_irreducible K _ _ p hp).valuation.ne_zero_iff.mpr hr)),
  map_zero' := sorry,
  add_le' := 
  begin
    intros r s,
    by_cases r + s = 0,
    { simp only [h, dif_pos],
      by_cases hr : r = 0,
      { have hs : s = 0,
        {sorry},
        simp only [hs, hr, dif_pos],
        linarith },
      { have hs : ¬ s = 0,
        {sorry},
        simp only [hs, hr, not_false_iff, dif_neg],
        exact add_nonneg (zpow_nonneg (le_of_lt hc_pos) _) 
          (zpow_nonneg (le_of_lt hc_pos) _) } },
    { simp only [h, not_false_iff, dif_neg],
      by_cases hr : r = 0,
      { have hs : ¬ s = 0,
        {sorry},
        simp only [hr, hs, not_false_iff, zero_add, dif_pos, dif_neg] },
      { by_cases hs : s = 0,
        {sorry},
        {sorry} } }
  end,
  neg' := sorry,
  map_one' := sorry,
  map_mul' :=
  begin
    intros x y,
    simp [mul_eq_zero, valuation.map_mul],
    by_cases (x = 0 ∨ y = 0),
    {sorry},
    { rw not_or_distrib at h,
      simp only [h.1, h.2, or_self, not_false_iff, dif_neg],
      rw ←@zpow_add₀ _ _ c (by linarith),
      congr,
      rw ←to_add_mul,
      congr,
      rw ←with_zero.coe_inj,
      push_cast,
      repeat {rw with_zero.coe_unzero} },
  end,
  eq_zero_of_map_eq_zero' :=
  begin
    intros x hx,
    by_contra,
    simp only [h, not_false_iff, dif_neg] at hx,
    linarith [zpow_eq_zero hx]
  end }

@[simp] lemma mul_ring_norm.adic_def {K : Type*} [field K] [decidable_eq (ratfunc K)] 
  (c : ℝ) (hc_pos : 0 < c) (hc_one_lt : 1 < c) {p : polynomial K} (hp : irreducible p) 
    (r : ratfunc K): mul_ring_norm.adic c hc_pos hc_one_lt hp r = if hr : r = 0 then 0 else 
      c ^ multiplicative.to_add (with_zero.unzero ((
        @polynomial.maximal_ideal_of_irreducible K _ _ p hp).valuation.ne_zero_iff.mpr hr)) 
:= rfl

lemma mul_ring_norm.adic_is_nonarchimedean (K : Type*) [field K] [decidable_eq (ratfunc K)] (c : ℝ)
  (hc_pos : 0 < c) (hc_one_lt : 1 < c) {p : polynomial K} (hp : irreducible p) :
  is_nonarchimedean (@mul_ring_norm.adic K _ _ c hc_pos hc_one_lt p hp) :=
begin
  intros x y,
  simp only [nonempty_of_inhabited, mul_ring_norm.adic_def, le_max_iff],
  by_cases x + y = 0,
  {sorry},
  { simp only [h, not_false_iff, dif_neg],
    by_cases hx : x = 0,
    { have hy : ¬ y = 0,
      {sorry},
      simp only [hx, hy, not_false_iff, zero_add, dif_neg, le_refl, or_true] },
    { left,
      simp only [hx, not_false_iff, dif_neg],
      repeat {rw ←real.rpow_int_cast},
      apply real.rpow_le_rpow_of_exponent_le,
      { linarith },
      { sorry } } }
end

end adic

open filter

-- Done in PR17863
lemma Sum_le {R : Type*} [ring R] (f : mul_ring_norm R) (n : ℕ) {ι : ℕ → R} : 
  f (∑ i in finset.range n, ι i) ≤ ∑ i in finset.range n, f (ι i) := sorry

-- Done in PR17863
lemma is_nonarchimedean_iff_exists_ne_zero_map_nat_mul_le_one {R : Type*} 
  [comm_ring R] {f : mul_ring_norm R} :
    is_nonarchimedean f ↔ (∃ x : R, x ≠ 0 ∧ ∀ n : ℕ, f (n * x) ≤ 1) := sorry

lemma unknown_name1 {K : Type*} [field K] [decidable_eq (ratfunc K)]
  {f : mul_ring_norm (ratfunc K)} (hf_nontriv : f ≠ 1) 
    (hf_triv_K : ∀ {x : K} (hx : x ≠ 0), f (ratfunc.C x) = 1) :
      is_nonarchimedean f :=
begin
  rw is_nonarchimedean_iff_exists_ne_zero_map_nat_mul_le_one,
  refine ⟨1, _⟩,
  simp only [ne.def, one_ne_zero, not_false_iff, mul_one, true_and],
  intro n,
  have hn1 : ratfunc.C (n : K) = (n : ratfunc K),
  { simp only [map_nat_cast] },
  by_cases h : (n : K) = 0,
  { have hn : (n : ratfunc K) = 0,
    { rw ← hn1,
      rw h,
      simp only [map_zero] },
    rw hn,
    simp only [map_zero, zero_le_one] },
  { specialize hf_triv_K h,
    rw hn1 at hf_triv_K,
    rw hf_triv_K }
end

lemma mul_ring_norm.is_nonarchimedaen_eq_max_of_neq {R : Type*} [non_assoc_ring R] 
  {f : mul_ring_norm R} (hf : is_nonarchimedean f) {r s : R} (h_neq : f r ≠ f s) : 
    f (r + s) = max (f r) (f s) :=
begin
  have hf₁ := hf,
  specialize hf r s,
  cases ne.lt_or_lt h_neq with h₁ h₂,
  { specialize hf₁ (r + s) (-r),
    simp only [add_neg_cancel_comm, map_neg_eq_map, le_max_iff] at hf₁,
    cases hf₁ with h₃ h₄,
    { have hrs : f r ≤ f s := by linarith,
      rw max_eq_right hrs at hf ⊢,
      linarith },
    { linarith } },
  { specialize hf₁ (r + s) (-s),
    simp only [add_neg_cancel_right, map_neg_eq_map, le_max_iff] at hf₁,
    cases hf₁ with h₃ h₄,
    { have hrs : f s ≤ f r := by linarith,
      rw max_eq_left hrs at hf ⊢,
      linarith },
    { linarith } }
end

lemma unknown_name {R : Type*} [non_assoc_ring R] {f : mul_ring_norm R} 
  (hf : is_nonarchimedean f) (s : finset ℕ) {g : ℕ → R} {a : ℕ}
    (h_max : ∀ p : ℕ, f (g p) ≤ f (g a)) :
      f (∑ p in s, g p) = f (g a) :=
begin
  sorry
end

/-- Ostrowski's Theorem -/
theorem rat_ring_norm_p_adic_or_real' (K : Type*) [field K] [decidable_eq (ratfunc K)]
  (c : ℝ) (hc_pos : 0 < c) (hc_one_lt : 1 < c) (f : mul_ring_norm (ratfunc K))
    (hf_nontriv : f ≠ 1) (hf_triv_K : ∀ {x : K} (hx : x ≠ 0), f (ratfunc.C x) = 1) :
      (mul_ring_norm.equiv f (mul_ring_norm.infty K c hc_pos hc_one_lt)) ∨
        ∃ (p : K[X]) [hp : irreducible p],
          mul_ring_norm.equiv f (@mul_ring_norm.adic K _ _ c hc_pos hc_one_lt p hp) :=
begin
  by_cases 1 < f (ratfunc.mk X 1),
  { left,
    let c₁ := 1 / f (ratfunc.mk X 1),
    have hc₁ : 0 < c₁,
    {sorry}, -- easy
    have hc₂ : 0 ≤ c₁,
    { linarith [hc₁] },
    have hc₃ : c₁ ≠ 1,
    {sorry}, -- easy as well
    have hc : c ≠ 0,
    { linarith },
    have hc1 : 0 ≤ c,
    { linarith },
    have h₁ : ∀ x : K[X], f (ratfunc.mk x 1) = c₁ ^ -(x.nat_degree : ℝ),
    { intro x,
      nth_rewrite 0 as_sum_support_C_mul_X_pow x,
      have h₁ : ratfunc.mk (x.support.sum (λ (i : ℕ), C (x.coeff i) * X ^ i)) 1
      = ∑ p in x.support, (ratfunc.mk (C (x.coeff p) * X ^ p) 1),
      {sorry},
      rw h₁, clear h₁,
      have h₂ : ∀ (p : ℕ), f (ratfunc.mk (C (x.coeff p) * X ^ p) 1)
        ≤ f (ratfunc.mk (C (x.coeff (nat_degree x)) * X ^ (nat_degree x)) 1),
      {sorry},
      have hf : is_nonarchimedean f,
      { exact unknown_name1 hf_nontriv @hf_triv_K },
      rw unknown_name hf (x.support) h₂,
      clear h₂,
      have h₃ : f (ratfunc.mk (C (x.coeff x.nat_degree) * X ^ x.nat_degree) 1)
         = f (ratfunc.mk (C (x.coeff x.nat_degree)) 1) * f (ratfunc.mk (X ^ x.nat_degree) 1),
      {sorry},
      rw h₃,
      clear h₃,
      have h₄ : f (ratfunc.mk (C (x.coeff x.nat_degree)) 1) = 1,
      {sorry},
      rw h₄,
      clear h₄,
      rw one_mul,
      have h₅ : f (ratfunc.mk (X ^ x.nat_degree) 1) = (f (ratfunc.mk X 1)) ^ (x.nat_degree),
      {sorry},
      rw h₅,
      clear h₅,
      dsimp [c₁],
      rw one_div,
      rw ←real.rpow_neg_one,
      rw ←real.rpow_mul,
      { simp only [neg_mul, one_mul, neg_neg, real.rpow_nat_cast] },
      sorry}, -- main step here
    refine ⟨-real.logb c₁ c, _, _⟩,
    {sorry}, -- 0 < -real.logb c₁ c-
    { ext,
      rw [mul_ring_norm.infty_def],
      by_cases h₂ : x = 0,
      {sorry}, -- easy
      { simp only [h₂, if_false],
        have h₃ := h₁ (x.num),
        specialize h₁ x.denom,
        have h₄ : x = (ratfunc.mk x.num 1) / (ratfunc.mk x.denom 1),
        {sorry}, -- quite tricky here
        rw h₄,
        have h₅ : f (ratfunc.mk x.num 1 / ratfunc.mk x.denom 1) = f (ratfunc.mk x.num 1) / f (ratfunc.mk x.denom 1),
        {sorry}, -- This should be a separate lemma
        rw h₅,
        rw [h₁, h₃],
        rw ←real.rpow_sub hc₁,
        field_simp,
        rw ←real.rpow_mul hc₂,
        rw ←neg_mul_comm,
        field_simp,
        rw mul_comm,
        rw real.rpow_mul hc₂,
        rw real.rpow_logb_eq_abs hc₁ hc₃ hc,
        rw abs_eq_self.2 hc1,
        dsimp [ratfunc.int_degree],
        rw ←real.rpow_int_cast,
        push_cast } } },
  { right,
    sorry}
end
